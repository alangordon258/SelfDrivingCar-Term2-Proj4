# PID Controller Project

[![Udacity - Self-Driving Car NanoDegree](https://s3.amazonaws.com/udacity-sdc/github/shield-carnd.svg)](http://www.udacity.com/drive)

Overview
---
This repository contains my submission for the PID Controller Project, which is part of the curriculum for term 2 of the Udacity Self-Driving Car Engineer Nanodegree Program. The goal of this project is to implement a PID controller in C++ to maneuver the vehicle around the lake race track from the Behavioral Cloning Project. The simulator provides the cross track error (CTE) and the velocity (mph) in order to compute the appropriate steering angle.

This submission satisfied project [rubric](https://review.udacity.com/#!/rubrics/824/view). 
![alt text](./PIDScreenShot.png)

[//]: # (Image References)
[image1]: ./analysis/NISlong30_00yaw30_00.jpg "30.00_30.00"
[image2]: ./analysis/NISlong1_25yaw0_25.jpg "1.25_0.25"
[image3]: ./analysis/NISlong0_75yaw0_50.jpg "0.75_0.50.jpg"

### Running the code
To fulfill the requirement that it must be possible to run the project in three different modes: considering laser only, with considering radar only, or with using both sensors, I  added two optional parameters to the main.cpp file included with the starter code for the project. 

The arguments that can be passed to UnscentedKF are as follows:

| Argument Position (argc)     | Description                                  | Default         | 
|:-----------------:|:--------------------------------------------:|:---------------:| 
| 1     | The path to the output file where the NIS values will be written             | No file will be written            |
| 2 | laser, radar, both               | both           | 

The following are some example command lines
```sh
./UnscentedKF output.txt radar
./UnscentedKF output2.txt both
./UnscentedKF output3.txt
```
I also created a data analysis [application](./analysis/dataanalysis.py) using Python and Pandas which was used to generate the NIS plots shown below and to validate that the percentage of NIS values was between the range specified in the readme.txt file for the project. This file can be run as follows where output.txt is the file generated by UnscentedKF as shown above.
```sh
python dataanalysis.py --file output.txt
```

### Results
I knew from my study of harmonic systems as an undergraduate engineering student that the coefficient Kp was the equivalent of a spring constant and Kd is the equivalent of a damping coefficient. My intuition told me that the integral coefficient Ki would be small. And that the control response of the vehicle would be dominated by the spring and damping terms. 

 In terms of a starting point for the coefficients, I needed to determine the magnitudes of the proportional, derivative, and integral errors. I added logic to return the maximum error each term after driving a lap, which I found to be about 2000 steps at the default throttle setting of 0.3. In order to get the car around at least once, I needed to come up with a set of starting parameters that would get the car around the track at least once. So I started with the following parameters:

Kp=1.0
Kd=1.0
Ki=0.0001

I determined the initial value for Ki by observing the value of the integral error which was of the order of magnitude 10^2. I wanted the result of multiplying Ki by the integral error to be at least an order of magnitude less than the result of the otherPlease note that in the code I turned the parameters Kp, Kd, and Ki into an array p of size 3 as follows: p[0]=Kp, p[1]=Kd, and p[2]=Ki.

With these values the car didn’t stay on the track for very long. I could see from how the car was whipping quickly back and forth that the spring coefficient (Kp) was too high. So I cut it in half to 0.5 and tried again. With these values, the car went farther, but still went off the track before it got to the bridge. I cut Kp in half again to 0.25 and I was able to get  the car around the track (weaving back and forth the whole way) using the default throttle setting (0.3) with the following coefficients:

Kp=0.25
Kd=1.0
Ki=0.0

Technically, I could have thrown up my hands here and declared victory, but that wouldn’t have been very satisfying. I wanted to go faster and to try twiddle. I knew that I could reduce the weaving by increasing the damping, so I increased Kd to 2.0 and then to 3.0. At this point the car was driving well enough that I started increasing the speed. I was able to get the car to go around the track, albeit with some lurid slides at the corner leading on to the main straight, by decreasing Kp to 0.15 in .05 increments. At this point, the car was driving quite well and given that the car was clearly at the limit of adhesion in the corner entering the main straight, I figured that I was going to be hard pressed to improve thing using twiddle. I tried anyway and sure enough the coefficients didn’t change significantly after a number of loops ending with 

Kp=0.15
Kd=3.0
Ki=0.00010729

I decided it was time to try adding a PID controller for the throttle. Since I knew that the maximum throttle value I could achieve with a static throttle was 0.6, I decided to start with a constant value of 0.65 adjusted by a control value that subtracted from this amount by a value that was proportional to the cte and the derivative and integral of the cte just like the steering. One significant difference between the throttle and the steering is that it is not signed. So I used the absolute value of the cte. I modified my PID class so that I could pass a parameter to the Init class that specified whether twiddle was to be run or not. So I froze my steering values and started with the following values for the throttle PID controller (not that I assumed that the bias was zero):

Kp=0.10
Kd=0.10
Ki=0.0

This worked quite well immediately. So I increased the constant value of the speed to 0.70 and it crashed. So I bumped up the Kp and Kd values to 0.15. This worked to keep the car on the track. So I bumped up the constant part of the speed to 0.75 and it crashed, so I increased Kp and Kd to 0.2. I felt that the braking was a little too heavy handed in the turn entering the main street so I reduced Kp to 0.18 and then to 0.19 when I found out that with 0.18 it would crash after a large number of laps. So the parameters I used for the throttle were

Kp=0.19
Kd=0.21
Ki=0.0

At this point the car was achieving better than 70 mph on the (relatively) straight section of the track and was sliding through several turns at the limit of adhesion. I figured it would be difficult to go faster without being more heavy handed with the brake, which would spoil the fun and ruin the overall lap time even if it might allow me to achieve a higher speed on the straight. The car was weaving a little bit now as the coefficients for the steering PID controller were optimized for a lower speed. So I froze the throttle controller coefficients to those outlined above and ran twiddle again for the steering starting with the coefficients that I had determined previously. I thought I needed to add more damping, but twiddle actually reduced both Kp and Kd slightly to the following values:

Kp=0.135
Kd=2.72943
Ki=0.00011

At this point I decided to call it quits, at least as far as the steering PID controller is concerned. Because the car was sliding around quite a bit, I decided to let it run for a while to make sure it didn’t go off the track after a while. Eventually, I realized that it did at times and to prevent this, I changed the throttle controller coefficients to the following:

Kp=0.21
Kd=0.1
Kd=0.0

I did discover one more thing when I tried to capture a video of my car. The software does not have a preset sample rate, it just samples as fast as it can. So if anything caused the frequency of the control input to change (such as running video capture software of the machine on which it is running), it would cause the car to crash. This was an important discovery because it raises the possibility that the car will crash when it is run on a different computer.


Looking at the screenshot of the Udacity simulator above you can see that my Unscented Kalman Filter is working correctly. The red and blue circles are simulated LIDAR and Radar readings. The green triangles represent the predicted position from my Kalman Filter. Notice that the green triangles trace a smooth and consistent path even though there is a substantial amount of noise in the sensor readings. I achieved the RMSE shown below (in the far right column) when running my unscented Kalman Filter with Dataset 1 and the optimum values for the process noise standard deviation for longitudinal and yaw acceleration . The RMSE values for the Unscented Kalman filter are well within the tolerances from the [rubric](https://review.udacity.com/#!/rubrics/783/view):

| X Vector | RMSE Extended KF | RMSE Unscented KF |
|:-----:|:-------------:|:-------------:|
| X  | 0.0973  | 0.0645 |
| Y  | 0.0855  | 0.0816 |
| VX  | 0.4513  | 0.3081 |
| VY  | 0.4399  | 0.2573 |

I also included the results from my Extended Kalman Filter project (the middle column) to show the improvement achieved by both using an Unscented Kalman Filter as well as using a Constant Turn Rate and Velocity (CTRV) motion model instead of the Constant Velocity (CV) model used in the Extended Kalman Filter project. Notice that the Unscented Kalman filter with CTRV is significantly better for all elements of the RMSE as compared to the Extended Kalman Filter with CV.

In this project, we were also required to tune the process noise standard deviation for both longitudinal and yaw acceleration to achieve RMSE values below that specified in the project [rubric](https://review.udacity.com/#!/rubrics/783/view). The starter code for the project initialized both of these values to 30. Using a value of 30 for the standard deviations yielded the following values for the RMSE:

| X Vector | RMSE Unscented KF |
|:-----:|:-------------:|
| X  | 0.0979  |
| Y  | 0.1208  |
| VX  | 0.8136  |
| VY  | 0.9955  |

Obviously, these results are very poor and well outside the range of values required by the [rubric](https://review.udacity.com/#!/rubrics/783/view). Some insight can be gained by running a consistency check using the Normalized Innovation Squared (NIS). This yielded the following.

![alt text][image1] 

The 95% chi squared value is shown as the orange line for each measurement type. The value is 7.815 for radar (3 degrees of freedom) and 5.991 for laser (2 degrees of freedom). The charts for both measurement types show that we are over-estimating the uncertainty in our system. Following the direction provided in the course material, the process noise should be set to half of the maximum longitudinal and yaw acceleration found in our environment. I did some research to investigate what these maximum acceleration values should be. I found the following [article](https://www.cyclingforums.com/threads/cornering-gs-on-a-bike.199320/page-3) which suggested that a skilled bicycle rider could do 32 mph on a 100 foot radius corner. Converting this to radians per second yields ~ 0.50 rad/s. If we make the asssumption that this same rider could transition from going straight to cornering at this rate in 1 second, then the maximum acceleration equals 0.5 rad/s2. 

For the longitudinal acceleration, the following [source](https://www.physicsforums.com/threads/how-to-calculate-bicycle-acceleration.504904/) suggests that a good number for the maximum acceleration for a bicycle is 2.5 m/s2. So half of each of these values suggests that we should use: 1.25 m/s2 and 0.25 rad/s2 for the process noise standard deviation longitudinal and lateral acceleration respectively. Running an NIS consistency check using these values yields the following graphs:

![alt text][image2]

There isn't nearly as much difference in these graphs as I expected, but you can clearly see a difference and these graphs look closer to the optimum shown in the course material. More importantly, the RMSE yields the following values which are better than those required by the [rubric](https://review.udacity.com/#!/rubrics/783/view):

| X Vector | RMSE Unscented KF |
|:-----:|:-------------:|
| X  | 0.0748  |
| Y  | 0.0819  |
| VX  | 0.3283  |
| VY  | 0.2795  |

I decided to spend a little more time to see if I could do better. The course material states that you should choose the process noise to be higher than half of the maximum acceleration if you want your application to react faster. If your priority is smooth estimations, then you choose the process noise to be a little lower. Experimentation led to the following values:

|Longitudinal |   Yaw | X |  Y |  Vx | Vy |
|:-----:|:-------------:|:-----:|:-------------:|:-----:|:-------------:|
| 1.25 | 0.25 | 0.0748 | 0.0819 | 0.3283 | 0.2795 |
| 1.5 | 0.25 | 0.0761 | 0.0824 | 0.3315 | 0.284 |
| 2.0 | 0.25 | 0.078 | 0.0837 | 0.338 | 0.2929 |
| 1.0 | 0.25 | 0.0732 | 0.0814 | 0.3254 | 0.2752 |
| 0.75 | 0.25 | 0.0712 | 0.0815 | 0.3229 | 0.2713 |
| 0.5 | 0.25 | 0.0686 | 0.0833 | 0.3211 | 0.2685 |
| 0.25 | 0.25 | 0.0668 | 0.0929 | 0.322 | 0.2695 |
| 0.75 | 0.5 | 0.0645 | 0.0815 | 0.3078 | 0.2571 | ***
| 0.75 | 0.75 | 0.0634 | 0.0827 | 0.3085 | 0.2596 |
| 0.75 | 0.375 | 0.0662 | 0.81 | 0.3113 | 0.2598 |

As you can see the lowest RMSE vector is found for process noise longitudinal and lateral acceleration values of 0.75 and 0.5 respectively. The NIS consistency check at those values looks as follows:

![alt text][image2]

Using these values, 221 of 249 radar measurement values had a NIS value between 0.35 and 7.815 which is 89%.


